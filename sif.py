# import re


# Stopwatch from Tkinter /////////////

# from Tkinter import *
# import time

# def Main():
#     global root

#     root = Tk()
#     root.title("Stopwatch")
#     width = 600
#     height = 200
#     screen_width = root.winfo_screenwidth()
#     screen_height = root.winfo_screenheight()
#     x = (screen_width / 2) - (width / 2)
#     y = (screen_height / 2) - (height / 2)
#     root.geometry("%dx%d+%d+%d" % (width, height, x, y))
#     Top = Frame(root, width=600)
#     Top.pack(side=TOP)
#     stopWatch = StopWatch(root)
#     stopWatch.pack(side=TOP)
#     Bottom = Frame(root, width=600)
#     Bottom.pack(side=BOTTOM)
#     Start = Button(Bottom, text='Start', command=stopWatch.Start, width=10, height=2)
#     Start.pack(side=LEFT)
#     Stop = Button(Bottom, text='Stop', command=stopWatch.Stop, width=10, height=2)
#     Stop.pack(side=LEFT)
#     Reset = Button(Bottom, text='Reset', command=stopWatch.Reset, width=10, height=2)
#     Reset.pack(side=LEFT)
#     Exit = Button(Bottom, text='Close', command=stopWatch.Exit, width=10, height=2)
#     Exit.pack(side=LEFT)
#     Title = Label(Top, text="Stopwatch For Beginners", font=("arial", 18), fg="white", bg="black")
#     Title.pack(fill=X)
#     root.config(bg="black")
#     root.mainloop()


# class StopWatch(Frame):

#     def __init__(self, parent=None, **kw):
#         Frame.__init__(self, parent, kw)
#         self.startTime = 0.0
#         self.nextTime = 0.0
#         self.onRunning = 0
#         self.timestr = StringVar()
#         self.MakeWidget()

#     def MakeWidget(self):
#         timeText = Label(self, textvariable=self.timestr, font=("times new roman", 50), fg="green", bg="black")
#         self.SetTime(self.nextTime)
#         timeText.pack(fill=X, expand=NO, pady=2, padx=2)

#     def Updater(self):
#         self.nextTime = time.time() - self.startTime
#         self.SetTime(self.nextTime)
#         self.timer = self.after(50, self.Updater)

#     def SetTime(self, nextElap):
#         minutes = int(nextElap / 60)
#         seconds = int(nextElap - minutes * 60.0)
#         miliSeconds = int((nextElap - minutes * 60.0 - seconds) * 100)
#         self.timestr.set('%02d:%02d:%02d' % (minutes, seconds, miliSeconds))

#     def Start(self):
#         if not self.onRunning:
#             self.startTime = time.time() - self.nextTime
#             self.Updater()
#             self.onRunning = 1

#     def Stop(self):
#         if self.onRunning:
#             self.after_cancel(self.timer)
#             self.nextTime = time.time() - self.startTime
#             self.SetTime(self.nextTime)
#             self.onRunning = 0

#     def Exit(self):
#             root.destroy()
#             exit()

#     def Reset(self):
#         self.startTime = time.time()
#         self.nextTime = 0.0
#         self.SetTime(self.nextTime)

# if __name__ == '__main__':
#     Main()

# NOTE: general way to read/write a file
# # will make a file, or overwrite one of the same name
# def mk_f(f_name):
# # defaults to making/opening the file in cwd
#   with open(f_name, 'w') as f:
#     f.write("I'm a ... " + p1)

# mk_f("purchase_holder")
  
  # formatting for writing code to a text document from inside a program
#   lines = []
# lines.append('def print_success():')
# lines.append('    print "sucesss"')
# "\n".join(lines)

# ///////////////

# User input is obtained by [raw_input('prompt: )] in python 2.x
# x2 = raw_input('input x2')
# print(x2)
# x3 = raw_input('input x3')
# print(x3)

# x = "i3on34g/10"
# cutoff = x[:-2]
# new = cutoff + "9"
# print(new)

#  force 2 digits to always show
#     # zfill forces 2 digits to always appear
#     t1.write(str(th).zfill(2)+ ":"+ str(tm).zfill(2)+":"+ str(ts).zfill(2), font=("arial", 40, "normal"))

# create / generate range
# Use the range to iterate over different pages to run 2 - 13 automated instead of doing each by hand
#  .... .... . .. .. 
# list_2thru13 = range(2, 14)

# x.append("9")

# url = 'https://xxyyzz.org/1103211/9444ca87d5/?p=33'

#  find a string that returns a match
# x = int(re.findall("[^\D]*$", url)[0])
# y = x - 1
# print(y)

# Find all divs with something in it....
# all_divs = content_pg_soup.find_all("div")
# for div in all_divs:
#   title1 = div.get("title")
#   if title1 == "This alternative script was generated by a piece of software":
#     print(div)

#  Scan for all available links on page
# all_anchortags = content_pg_soup.find_all("a")
# counter2 = 0
# for anch in all_anchortags:
#   if anch.get("href"):
#     print("link at idx " + str(counter2) + ' ---  ' + anch.get("href"))
#     counter2 += 1

# extract unicode value from <title> tag
# \u672c\u65e5\u306f\u5b9a\u4f11\u65e5\u3067\u3059\u3002
# x1 = str((content_pg_soup.find_all('title')))
# uni_jp = re.findall("(u[^\s]*)", x1)[0]
# print(uni_jp)

# returning a string with python regex
# a = 'https://tatoeba.org//eng/sentences/show/195867'

# a2 = re.findall("[^\D]*$", a)[0]
# print(a2)

# Dev note:
  # .find_all('tag', recursive=False) will only find direct descendants

# beautiful soup find by attribute
# var111 = content_pg_soup.findall('div', lang="en")

# # image extraction from bauitufl soup example 
# #  find all images, extract to function
# # imgdata = {}
# # for img in soup.find_all('img'):
# #   imgdata[(img.get('src'))] = img.get('title')

# writing unicode chars to proper letter output in a word file

# doc = docx.Document()
# for jpn in furi_list:
  # purified_jpn = ftfy.fix_encoding(jpn)
  # fixed_jpn = ftfy.fix_text(purified_jpn)
  # doc.add_paragraph(purified_jpn)
# doc.save('jpTest4.docx')

# Purify mojibake with a given line variable: jpn_line
# purified_jpn = ftfy.fix_encoding(jpn_line)
# fixed_jpn = ftfy.fix_text(purified_jpn)

# make a list from a range --- 
# list1 = range(2, 14)
# for y in list1:
#   print(y)
#  prints 2 thru 13 (up to but not including second arg, 14)

# replace "T-dollIndex" at end of url with tdoll_name var.
# re.sub("T-.*$", tdoll_name, index_url)

# getting an attribute's content from a list of tags, then checking if they're a gif-type
# for x in soup.findAll('img'):
#     img_title = str(x.get("title"))
#     # gif type targeted here
#     if img_title[-4:] == ".gif":
#       found_gif_link = x.parent.get("href")

# Handle un-printible chars by replacement:
# txt_content.encode('ascii', 'replace')

# find all sibling elements on a level
# trivia_bullets = soup.find(id="Trivia").find_next('ul').find_all('li', recursive=False)

# open shit from web browser
# import webbrowser
# url="https://www.youtube.com/watch?v=XI5Bvplb7pQ"
# webbrowser.open(url)


# # will make a file, or overwrite one of the same name
# def mk_f(f_name, info_to_save):
# # defaults to making/opening the file in cwd
#   with open(f_name, 'w') as f:
#     f.write(info_to_save)

# # simple read function, returning all lines read
# def rd_f_nreturn_lines(f_name):
#   with open(f_name, 'r') as f:
#     lines = f.readlines()
#   return lines

# def convert_dict_to_str(dict1):
#   start_bracket = "{"
#   big_string = ""
#   end_bracket = "}"
#   counter1 = 1
#   for k in dict1:
#     v = str(dict1[k])
#     # don't add a comma if there's only one item or if you're at the last item
#     if counter1 == len(dict1):
#       big_string += (k + " : " + v)
#     else:
#       big_string += (k + " : " + v + ", ")
#     counter1 += 1
  
#   string_dict = (start_bracket + big_string + end_bracket)
#   return string_dict

# current date and time in simple string format
# datetime.datetime.now().strftime("%Y-%m-%d %H:%M")

# def convert_list_to_str(l1):
#   start_bracket = "["
#   big_string = ""
#   end_bracket = "]"
#   counter1 = 1
#   for i in l1:
#     if counter1 == len(l1):
#       big_string += str(l1[counter1-1])
#     else:
#       big_string += (str(l1[counter1-1]) + ", ")
#     counter1 += 1
  
#   string_list = (start_bracket + big_string + end_bracket)
#   return string_list

# regex re : match at least one thing after the total phrase (wiki/). without capturing the identifying phrase
# this is called "a lookbehind assertion"
# re.match("(?<=wiki/).+", src_url)

  # print all x's together, all y's and all z's
    # d_arr = [x1, y1, z1],  [x2, y2, z2],  [x3, y3, z3]
    # for y in range(0, len(data_arr[0])):
    #   for x in range(0, 4):
    #     print(data_arr[x][y].encode("ascii", "replace"))
    #  similar to:  
    #           zip(*data_arr)